/**
 * REMESITA API REST
 * Api de remesita.com para desarrolladores. Primero obten tu apiKey y apiSecret, y para autenticarte debes ejecutar el endpoint rest/v1/auth en la respuesta obtendrás un token de acceso que debes usar en el resto de peticiones
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://remesita.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Body {
    /**
    * Número de tarjeta Visa de origen
    */
    'from': string;
    /**
    * Número de tarjeta Visa de destino
    */
    'to': string;
    /**
    * Monto a transferir
    */
    'amount': number;
    /**
    * Moneda de la transferencia (MXN o USD). Si no se envía, se asume USD por defecto.
    */
    'currency'?: string;
    /**
    * Comentario o concepto de la transacción
    */
    'memo': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "memo",
            "baseName": "memo",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Body.attributeTypeMap;
    }
}

export class Body1 {
    /**
    * ID del negocio que está generando el link de pago
    */
    'businessUnitId': string;
    /**
    * Monto a pagar
    */
    'amount': number;
    /**
    * Concepto de pago o comentario
    */
    'concept': string;
    /**
    * Dirección para recibir webhooks de notificaciones de pago en segundo plano
    */
    'ipnUrl'?: string;
    /**
    * URL a donde redireccionar si el pago es satisfactorio
    */
    'successUrl'?: string;
    /**
    * URL a donde redireccionar si el pago es cancelado
    */
    'cancelUrl'?: string;
    /**
    * Identificador externo para trazabilidad
    */
    'customId'?: string;
    /**
    * Nombre del pagador (si se conoce)
    */
    'payerName'?: string;
    /**
    * Teléfono del pagador (si se conoce)
    */
    'payerPhone'?: string;
    /**
    * Email del pagador (si se conoce)
    */
    'payerEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "businessUnitId",
            "baseName": "businessUnitId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "concept",
            "baseName": "concept",
            "type": "string"
        },
        {
            "name": "ipnUrl",
            "baseName": "ipnUrl",
            "type": "string"
        },
        {
            "name": "successUrl",
            "baseName": "successUrl",
            "type": "string"
        },
        {
            "name": "cancelUrl",
            "baseName": "cancelUrl",
            "type": "string"
        },
        {
            "name": "customId",
            "baseName": "customId",
            "type": "string"
        },
        {
            "name": "payerName",
            "baseName": "payerName",
            "type": "string"
        },
        {
            "name": "payerPhone",
            "baseName": "payerPhone",
            "type": "string"
        },
        {
            "name": "payerEmail",
            "baseName": "payerEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Body1.attributeTypeMap;
    }
}

export class Body2 {
    'apiKey'?: string;
    'apiSecret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiKey",
            "baseName": "api_key",
            "type": "string"
        },
        {
            "name": "apiSecret",
            "baseName": "api_secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Body2.attributeTypeMap;
    }
}

export class InlineResponse200 {
    /**
    * ID único del negocio
    */
    'id'?: string;
    /**
    * Nombre del negocio
    */
    'name'?: string;
    /**
    * Descripción del negocio
    */
    'description'?: string;
    /**
    * Logo del negocio
    */
    'logo'?: string;
    /**
    * Dominio del negocio
    */
    'domain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "logo",
            "baseName": "logo",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    /**
    * Indica si la transferencia fue exitosa
    */
    'success'?: boolean;
    /**
    * Mensaje de error en caso de fallo
    */
    'error'?: string;
    /**
    * ID de la transacción en caso de éxito
    */
    'tid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "tid",
            "baseName": "tid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class InlineResponse2002 {
    'success'?: boolean;
    'lockStatus'?: string;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "lockStatus",
            "baseName": "lockStatus",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002.attributeTypeMap;
    }
}

export class InlineResponse2003 {
    'items'?: Array<InlineResponse2003Items>;
    'pg'?: number;
    'pgSize'?: number;
    'pages'?: number;
    'total'?: number;
    'allowNext'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<InlineResponse2003Items>"
        },
        {
            "name": "pg",
            "baseName": "pg",
            "type": "number"
        },
        {
            "name": "pgSize",
            "baseName": "pgSize",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "allowNext",
            "baseName": "allowNext",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2003.attributeTypeMap;
    }
}

export class InlineResponse2003Items {
    'id'?: number;
    'type'?: string;
    'date'?: string;
    'amount'?: number;
    'amountUSD'?: number;
    'exchangeRate'?: number;
    'currency'?: string;
    'memo'?: string;
    'category'?: string;
    'payee'?: string;
    'website'?: string;
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "amountUSD",
            "baseName": "amountUSD",
            "type": "number"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "memo",
            "baseName": "memo",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "payee",
            "baseName": "payee",
            "type": "string"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2003Items.attributeTypeMap;
    }
}

export class InlineResponse2004 {
    'items'?: Array<InlineResponse2004Items>;
    /**
    * Total de tarjetas
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<InlineResponse2004Items>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2004.attributeTypeMap;
    }
}

export class InlineResponse2004Items {
    /**
    * Balance de la tarjeta
    */
    'balance'?: number;
    /**
    * Balance de la tarjeta formateado
    */
    'balanceFormatted'?: string;
    /**
    * Balance en USD
    */
    'balanceUSD'?: number;
    /**
    * Balance en USD formateado
    */
    'balanceUSDFormatted'?: string;
    /**
    * Estado de la tarjeta
    */
    'status'?: string;
    /**
    * Número de la tarjeta
    */
    'number'?: string;
    /**
    * Número de la tarjeta formateado
    */
    'numberFormatted'?: string;
    /**
    * Tasa de cambio
    */
    'exchangeRate'?: number;
    /**
    * CLABE de la tarjeta
    */
    'clabe'?: string;
    /**
    * Referencia de efectivo
    */
    'cashReference'?: string;
    /**
    * Indica si la tarjeta está bloqueada
    */
    'locked'?: boolean;
    /**
    * Alias de la tarjeta
    */
    'alias'?: string;
    /**
    * Indica si es la tarjeta principal
    */
    'main'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "balanceFormatted",
            "baseName": "balanceFormatted",
            "type": "string"
        },
        {
            "name": "balanceUSD",
            "baseName": "balanceUSD",
            "type": "number"
        },
        {
            "name": "balanceUSDFormatted",
            "baseName": "balanceUSDFormatted",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "numberFormatted",
            "baseName": "numberFormatted",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "number"
        },
        {
            "name": "clabe",
            "baseName": "clabe",
            "type": "string"
        },
        {
            "name": "cashReference",
            "baseName": "cashReference",
            "type": "string"
        },
        {
            "name": "locked",
            "baseName": "locked",
            "type": "boolean"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "main",
            "baseName": "main",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2004Items.attributeTypeMap;
    }
}

export class InlineResponse2005 {
    'items'?: Array<InlineResponse2005Items>;
    'pg'?: number;
    'pgSize'?: number;
    'pages'?: number;
    'total'?: number;
    'allowNext'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<InlineResponse2005Items>"
        },
        {
            "name": "pg",
            "baseName": "pg",
            "type": "number"
        },
        {
            "name": "pgSize",
            "baseName": "pgSize",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "allowNext",
            "baseName": "allowNext",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2005.attributeTypeMap;
    }
}

export class InlineResponse2005Items {
    'status'?: string;
    'speedMode'?: string;
    'reference'?: string;
    'sku'?: string;
    'recipientAccount'?: string;
    'swift'?: string;
    'institution'?: string;
    'senderName'?: string;
    'senderCountry'?: string;
    'recipientName'?: string;
    'recipientCountry'?: string;
    'recipientRelationship'?: string;
    'paymentMethod'?: string;
    'quotation'?: string;
    'senderCurrency'?: string;
    'exchangeRate'?: number;
    'lifeTime'?: string;
    'createdAt'?: Date;
    'payedAt'?: Date;
    'cancelAt'?: Date;
    'completedAt'?: Date;
    'institutionIcon'?: string;
    'cancelReason'?: string;
    'intent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "speedMode",
            "baseName": "speedMode",
            "type": "string"
        },
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "recipientAccount",
            "baseName": "recipientAccount",
            "type": "string"
        },
        {
            "name": "swift",
            "baseName": "swift",
            "type": "string"
        },
        {
            "name": "institution",
            "baseName": "institution",
            "type": "string"
        },
        {
            "name": "senderName",
            "baseName": "senderName",
            "type": "string"
        },
        {
            "name": "senderCountry",
            "baseName": "senderCountry",
            "type": "string"
        },
        {
            "name": "recipientName",
            "baseName": "recipientName",
            "type": "string"
        },
        {
            "name": "recipientCountry",
            "baseName": "recipientCountry",
            "type": "string"
        },
        {
            "name": "recipientRelationship",
            "baseName": "recipientRelationship",
            "type": "string"
        },
        {
            "name": "paymentMethod",
            "baseName": "paymentMethod",
            "type": "string"
        },
        {
            "name": "quotation",
            "baseName": "quotation",
            "type": "string"
        },
        {
            "name": "senderCurrency",
            "baseName": "senderCurrency",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "number"
        },
        {
            "name": "lifeTime",
            "baseName": "lifeTime",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "payedAt",
            "baseName": "payedAt",
            "type": "Date"
        },
        {
            "name": "cancelAt",
            "baseName": "cancelAt",
            "type": "Date"
        },
        {
            "name": "completedAt",
            "baseName": "completedAt",
            "type": "Date"
        },
        {
            "name": "institutionIcon",
            "baseName": "institutionIcon",
            "type": "string"
        },
        {
            "name": "cancelReason",
            "baseName": "cancelReason",
            "type": "string"
        },
        {
            "name": "intent",
            "baseName": "intent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2005Items.attributeTypeMap;
    }
}

export class InlineResponse2006 {
    'pg'?: number;
    'pgSize'?: number;
    'pages'?: number;
    'total'?: number;
    'allowNext'?: boolean;
    'items'?: Array<InlineResponse2006Items>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pg",
            "baseName": "pg",
            "type": "number"
        },
        {
            "name": "pgSize",
            "baseName": "pgSize",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "allowNext",
            "baseName": "allowNext",
            "type": "boolean"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<InlineResponse2006Items>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2006.attributeTypeMap;
    }
}

export class InlineResponse2006Items {
    'match'?: boolean;
    'status'?: string;
    'order'?: string;
    'createdAt'?: Date;
    'completedAt'?: Date;
    'paymentMethod'?: string;
    'sku'?: string;
    'quotation'?: number;
    'quotationCurrency'?: string;
    'recipientAccount'?: string;
    'recipientAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "match",
            "baseName": "match",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "completedAt",
            "baseName": "completedAt",
            "type": "Date"
        },
        {
            "name": "paymentMethod",
            "baseName": "paymentMethod",
            "type": "string"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "quotation",
            "baseName": "quotation",
            "type": "number"
        },
        {
            "name": "quotationCurrency",
            "baseName": "quotationCurrency",
            "type": "string"
        },
        {
            "name": "recipientAccount",
            "baseName": "recipientAccount",
            "type": "string"
        },
        {
            "name": "recipientAmount",
            "baseName": "recipientAmount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2006Items.attributeTypeMap;
    }
}

export class InlineResponse2007 {
    /**
    * Link acortado listo para ser redireccionado
    */
    'link'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2007.attributeTypeMap;
    }
}

export class InlineResponse2008 {
    'accessToken'?: string;
    'user'?: InlineResponse2008User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "InlineResponse2008User"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008.attributeTypeMap;
    }
}

export class InlineResponse2008User {
    'uid'?: string;
    'name'?: string;
    'phone'?: string;
    'email'?: string;
    'pictureUrl'?: string;
    'mainCard'?: string;
    'level'?: string;
    'countryISO'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "pictureUrl",
            "baseName": "pictureUrl",
            "type": "string"
        },
        {
            "name": "mainCard",
            "baseName": "mainCard",
            "type": "string"
        },
        {
            "name": "level",
            "baseName": "level",
            "type": "string"
        },
        {
            "name": "countryISO",
            "baseName": "countryISO",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008User.attributeTypeMap;
    }
}

export class InlineResponse2009 {
    /**
    * Balance combinado de la tarjeta prepago
    */
    'prepaidCardCombinedBalance'?: number;
    /**
    * Balance combinado de la tarjeta prepago en USD
    */
    'prepaidCardCombinedBalanceUsd'?: number;
    /**
    * Comisión de referidos
    */
    'referralsCommission'?: number;
    /**
    * Tasa de cambio de USD a MXN
    */
    'usd2mxn'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "prepaidCardCombinedBalance",
            "baseName": "prepaidCardCombinedBalance",
            "type": "number"
        },
        {
            "name": "prepaidCardCombinedBalanceUsd",
            "baseName": "prepaidCardCombinedBalanceUsd",
            "type": "number"
        },
        {
            "name": "referralsCommission",
            "baseName": "referralsCommission",
            "type": "number"
        },
        {
            "name": "usd2mxn",
            "baseName": "usd2mxn",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2009.attributeTypeMap;
    }
}

export class InlineResponse401 {
    'success'?: boolean;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse401.attributeTypeMap;
    }
}

export class InlineResponse404 {
    'success'?: boolean;
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse404.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "Body": Body,
    "Body1": Body1,
    "Body2": Body2,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "InlineResponse2002": InlineResponse2002,
    "InlineResponse2003": InlineResponse2003,
    "InlineResponse2003Items": InlineResponse2003Items,
    "InlineResponse2004": InlineResponse2004,
    "InlineResponse2004Items": InlineResponse2004Items,
    "InlineResponse2005": InlineResponse2005,
    "InlineResponse2005Items": InlineResponse2005Items,
    "InlineResponse2006": InlineResponse2006,
    "InlineResponse2006Items": InlineResponse2006Items,
    "InlineResponse2007": InlineResponse2007,
    "InlineResponse2008": InlineResponse2008,
    "InlineResponse2008User": InlineResponse2008User,
    "InlineResponse2009": InlineResponse2009,
    "InlineResponse401": InlineResponse401,
    "InlineResponse404": InlineResponse404,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AuthenticationApiApiKeys {
    Bearer,
}

export class AuthenticationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthenticationApiApiKeys, value: string) {
        (this.authentications as any)[AuthenticationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Autentica al usuario con api_key y api_secret
     * @param body JSON con api_key y api_secret
     * @param {*} [options] Override http request options.
     */
    public restV1AuthPost (body: Body2, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }> {
        const localVarPath = this.basePath + '/rest/v1/auth';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restV1AuthPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body2")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2008");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BusinessApiApiKeys {
    Bearer,
}

export class BusinessApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BusinessApiApiKeys, value: string) {
        (this.authentications as any)[BusinessApiApiKeys[key]].apiKey = value;
    }
    /**
     * Devuelve una lista de todos los negocios registrados en remesita
     * @summary Obtiene la lista de negocios registrados
     * @param {*} [options] Override http request options.
     */
    public restV1BusinessGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse200>;  }> {
        const localVarPath = this.basePath + '/rest/v1/business';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse200>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse200>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Crea un link de pago basado en los detalles proporcionados
     * @summary Genera un link de pago
     * @param body Detalles para generar el link de pago
     * @param {*} [options] Override http request options.
     */
    public restV1PaymentLinkPost (body: Body1, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }> {
        const localVarPath = this.basePath + '/rest/v1/payment-link';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restV1PaymentLinkPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body1")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2007;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2007");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefaultApiApiKeys {
    Bearer,
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
     * @param code 
     * @param {*} [options] Override http request options.
     */
    public restV1UserLockupCodeCodeGet (code: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/rest/v1/user/lockup-code/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling restV1UserLockupCodeCodeGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OperationsApiApiKeys {
    Bearer,
}

export class OperationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OperationsApiApiKeys, value: string) {
        (this.authentications as any)[OperationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Recupera una lista paginada de órdenes
     * @summary Obtiene una lista de órdenes
     * @param pg Número de página
     * @param pgSize Cantidad de elementos por página
     * @param start Fecha de inicio en formato Y-m-d H:i:s
     * @param end Fecha de finalización en formato Y-m-d H:i:s
     * @param status Estado para filtrar
     * @param {*} [options] Override http request options.
     */
    public restV1OperationOrdersGet (pg?: number, pgSize?: number, start?: Date, end?: Date, status?: 'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled', options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }> {
        const localVarPath = this.basePath + '/rest/v1/operation/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (pg !== undefined) {
            localVarQueryParameters['pg'] = ObjectSerializer.serialize(pg, "number");
        }

        if (pgSize !== undefined) {
            localVarQueryParameters['pgSize'] = ObjectSerializer.serialize(pgSize, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'start' | 'payed' | 'payment_under_review' | 'assigned' | 'completed' | 'canceled'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2005");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Recupera una lista paginada de operaciones P2P
     * @summary Obtiene una lista de operaciones P2P
     * @param pg Número de página
     * @param pgSize Cantidad de elementos por página
     * @param start Fecha de inicio en formato Y-m-d H:i:s
     * @param end Fecha de finalización en formato Y-m-d H:i:s
     * @param {*} [options] Override http request options.
     */
    public restV1OperationP2pGet (pg?: number, pgSize?: number, start?: Date, end?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }> {
        const localVarPath = this.basePath + '/rest/v1/operation/p2p';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (pg !== undefined) {
            localVarQueryParameters['pg'] = ObjectSerializer.serialize(pg, "number");
        }

        if (pgSize !== undefined) {
            localVarQueryParameters['pgSize'] = ObjectSerializer.serialize(pgSize, "number");
        }

        if (start !== undefined) {
            localVarQueryParameters['start'] = ObjectSerializer.serialize(start, "Date");
        }

        if (end !== undefined) {
            localVarQueryParameters['end'] = ObjectSerializer.serialize(end, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2006");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PrepaidCardsApiApiKeys {
    Bearer,
}

export class PrepaidCardsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PrepaidCardsApiApiKeys, value: string) {
        (this.authentications as any)[PrepaidCardsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Cambia el estado de bloqueo de una tarjeta específica
     * @summary Bloquea o desbloquea una tarjeta
     * @param number Número de tarjeta
     * @param {*} [options] Override http request options.
     */
    public restV1CardNumberTogglePost (number: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/rest/v1/card/{number}/toggle'
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling restV1CardNumberTogglePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2002");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Recupera una lista paginada de transacciones para una tarjeta específica
     * @summary Obtiene las transacciones de una tarjeta
     * @param number Número de tarjeta
     * @param pg Número de página
     * @param pgSize Tamaño de página
     * @param {*} [options] Override http request options.
     */
    public restV1CardNumberTransactionsPgPgSizeGet (number: string, pg: number, pgSize: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/rest/v1/card/{number}/transactions/{pg}/{pgSize}'
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)))
            .replace('{' + 'pg' + '}', encodeURIComponent(String(pg)))
            .replace('{' + 'pgSize' + '}', encodeURIComponent(String(pgSize)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling restV1CardNumberTransactionsPgPgSizeGet.');
        }

        // verify required parameter 'pg' is not null or undefined
        if (pg === null || pg === undefined) {
            throw new Error('Required parameter pg was null or undefined when calling restV1CardNumberTransactionsPgPgSizeGet.');
        }

        // verify required parameter 'pgSize' is not null or undefined
        if (pgSize === null || pgSize === undefined) {
            throw new Error('Required parameter pgSize was null or undefined when calling restV1CardNumberTransactionsPgPgSizeGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2003");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Permite transferir saldo entre dos cuentas Remesita especificadas por los números de tarjeta Visa.
     * @summary Transfiere saldo entre cuentas Remesita
     * @param body Detalles de la transferencia
     * @param {*} [options] Override http request options.
     */
    public restV1CardTransferBetweenPost (body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/rest/v1/card/transfer-between';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling restV1CardTransferBetweenPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Devuelve una lista de todas las tarjetas prepagadas en el sistema
     * @summary Obtiene la lista de tarjetas prepagadas
     * @param {*} [options] Override http request options.
     */
    public restV1CardsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }> {
        const localVarPath = this.basePath + '/rest/v1/cards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2004");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProfileApiApiKeys {
    Bearer,
}

export class ProfileApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProfileApiApiKeys, value: string) {
        (this.authentications as any)[ProfileApiApiKeys[key]].apiKey = value;
    }
    /**
     * Devuelve el balance y otros detalles relacionados
     * @summary Obtiene datos de balance
     * @param {*} [options] Override http request options.
     */
    public restV1BalanceGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }> {
        const localVarPath = this.basePath + '/rest/v1/balance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2009");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Obtener datos de un cliente a partir de su codigo de cliente/referidos
     * @param code 
     * @param {*} [options] Override http request options.
     */
    public restV1UserLockupCodeCodePost (code: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/rest/v1/user/lockup-code/{code}'
            .replace('{' + 'code' + '}', encodeURIComponent(String(code)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling restV1UserLockupCodeCodePost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
